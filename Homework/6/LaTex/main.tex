\documentclass{article}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bm}
\usepackage{float}
\restylefloat{table}

\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}

\usepackage[margin=1.25in]{geometry}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.86,0.27,0.22}

\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{CS5200: Homework \#6} % Title of the assignment

\author{Matthew Whitesides\\ \texttt{mbwxd4@umsystem.edu}} % Author name and email address

\date{\today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

  \maketitle % Print the title
 
  \begin{enumerate}
    \item \textbf{22.1-1 p. 592}.
    
    Essentailly to calculate an in-degree list of the vertecies in an adjacency-list graph we'd just need to iterate over each vertex $O(V)$.
    Then iterate through the linked list attatched to each vertex $O(E)$ and countt the number of vertecies.
    Therefore the total time complexity would be \bm{$O(V + E)$} where V is number of vertecies and E is number of edges comming out of the vertex.

    To calculate an out-degree list of the vertecies we'd also need to iterate over each vertex $O(V)$.
    Then iterate through the linked list attatched to each vertex $O(E)$ however this time we are counting each vertex in the edge list and adding them to our count in the vertex in list.
    Therefore the total time complexity would still be \bm{$O(V + E)$} where V is number of vertecies and E is number of edges going into each vertex in the edge list.

    A simple python program to simulate this is like so:

    \begin{lstlisting}
# A function for given a graph dictionary g we calculate the outdegree of each vertex.
def get_out_degree(g):
    out_degrees = {}
    # O(V) Time
    for v in g:
        out_degrees[v] = 0
        # O(Ei) Time note this is iterating the list even thoguh we have them in memory.
        for ei in g[v]:
            out_degrees[v] += 1 

    # Thus final time complexity is O(V + E)
    return out_degrees


def get_in_degree(g):
    in_degrees = {}
    # O(V) Time
    for v in g:
        in_degrees[v] = 0
        
    for v in g:
        # O(Ei) Time note this is iterating the list even thoguh we have them in memory.
        # This is essentailly the same as the previous except it's adding from the in list.
        for ei in g[v]:
            in_degrees[ei] += 1 

    # Thus final time complexity is still O(V + E)
    return in_degrees              
    \end{lstlisting}

    \begin{lstlisting}
adj_list = { "a": ["c", "f"],
  "b": ["c", "e"],
  "c": ["a", "b", "d", "e"],
  "d": ["c", "a", "f"],
  "e": ["c", "b"],
  "f": []
}

print("Out degrees:", get_out_degree(adj_list))
print("In degrees:", get_in_degree(adj_list))

# Output:
# Out degrees: {'a': 2, 'b': 2, 'c': 4, 'd': 3, 'e': 2, 'f': 0}
# In degrees: {'a': 2, 'b': 2, 'c': 4, 'd': 1, 'e': 2, 'f': 2}

adj_list = {
    1: [2, 3, 8, 4],
    2: [1, 3, 7, 5],
    3: [1, 2, 6],
    4: [3, 2, 1],
    5: [1],
    6: [1, 2, 3],
    7: [8, 1, 3],
    8: []
}

print("Out degrees:", get_out_degree(adj_list))
print("In degrees:", get_in_degree(adj_list))

# Output:
# Out degrees: {1: 4, 2: 4, 3: 3, 4: 3, 5: 1, 6: 3, 7: 3, 8: 0}
# In degrees: {1: 6, 2: 4, 3: 5, 4: 1, 5: 1, 6: 1, 7: 1, 8: 2}
    \end{lstlisting}

    \item \textbf{22.1-7 p. 593}.
    
    If we take the product of $B$ and $B^T$ for each entry $BB^{T}_{ij}$ we'd get:

    The sum of veticies value $B_i$ for each edge in the row with each edges vertex from $B^T_j$.
    Which if vertex $B_i = B^T_j$ would be 1 by 1 or -1 by -1 so we'd always get a positive number which is the total of the in degree and out degrees.

    However if we are comparing to differnt vertecies we'd be summing up the edges with each vertex. Therefore we'd have:

    \begin{equation}
      BB^T_{ij} =
      \begin{cases}
        \text{sum of in and out degrees,} & \text{if i = j,} \\
        \text{sum of edges between i and j,} & \text{otherwise,}
      \end{cases}
    \end{equation}

    \item \textbf{22.2-9 p. 602}.
    
    First lets start with a depth first search algorithm, as it traverses through the edges one way then we can go back. 
    As opposed to breadth which would give us an odd 360 path forcing us to cover edges multiple times.

    The basic idea is deapth first seach will traverses each node and backtracks when it hits the end, in this case we'll allow it to travese each twice.

    For the penny question following the same logic as the alogirthm if you place a penny in each hallyway you walk down you then can limit the hallways you allowing yourself to go down with ones that have less than two pennies.

    \begin{lstlisting}
      # Simple graph class using a dictionary as list of nodes and edges.
      class Graph:   
          def __init__(self): 
              self.G = {}
              
          def __str__(self):
              return str(self.G)
        
          def add_edge(self, u, v): 
              if u in self.G:
                  self.G[u].append(v) 
              else:
                  self.G[u] = [v]
        
          def DFS_visit(self, v, times_visited): 
              times_visited[v] += 1
              print(v, end = ' -> ') 
              
              for i in self.G[v]: 
                  if times_visited[i] < 2:  
                      self.DFS_visit(i, times_visited)
                      self.add_edge(v, i)
          
          # Modified DFS/DFS-Visit from 22.3 p. 604 in the book.
          def DFS(self): 
              times_visited = [0] * (len(self.G)) 
              
              for v in self.G:
                  self.DFS_visit(v, times_visited)
                  break      
    \end{lstlisting}

    \begin{lstlisting}
g = Graph() 
g.add_edge(0, 1) 
g.add_edge(1, 2) 
g.add_edge(2, 3) 
g.add_edge(3, 1) 

print(g)

g.DFS()

# {0: [1], 1: [2], 2: [3], 3: [1]}
# 0 -> 1 -> 2 -> 3 -> 1 -> 2 -> 3 -> 

g = Graph() 
g.add_edge(0, 1) 
g.add_edge(0, 2) 
g.add_edge(1, 2) 
g.add_edge(2, 0) 
g.add_edge(2, 3) 
g.add_edge(3, 3) 

print(g)

g.DFS()      

# Output:
# {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}
# 0 -> 1 -> 2 -> 0 -> 1 -> 2 -> 3 -> 3 ->
    \end{lstlisting}

    \item \textbf{22.3-12 p. 612}.
    
    Below is a modification to the alogirthm DFS on p. 604 where we add a new attribute to our Node type "cc" that says which connected component the node is a part of. 
    We do this by adding it before the color check.

    \begin{lstlisting}
import collections      

class Node:
    def __init__(self, value):
        self.value = value
        self.color = 'WHITE'
        self.cc = 0
      
    def __str__(self):
        return "({}, {}, CC: {})".format(self.value, self.color, self.cc)
    
    def __repr__(self):
        return str(self)
    
    def __hash__(self):
        return hash(self.value)
        
    def __eq__(self, other):
        return self.value == other.value

    def __gt__(self, other):
        return self.value > other.value
    
    def __lt__(self, other):
        return self.value < other.value

class Graph:    
    graph_dict = {}
    num_edges = 0

    def add_edge(self, vert, connected_vert):  
        if vert not in self.graph_dict:
            self.graph_dict[vert] = [connected_vert]
        else:
            self.num_edges += 1
            self.graph_dict[vert].append(connected_vert)
            
        if connected_vert not in self.graph_dict:
            self.graph_dict[connected_vert] = [vert]
        else:
            self.graph_dict[connected_vert].append(vert)

    def print_graph_dict(self):
        for key in self.graph_dict:
            print(str(key))
            for v in self.graph_dict[key]:
                print('\t' + str(v))
    
    # Algorithm based upon 22.3 p. 604
    def dfs(self):
        k = 1
        for u in self.graph_dict:
            if u.color == 'WHITE':
                u.cc = k
                k += 1
                self.dfs_visit(u)
                
    def dfs_visit(self, u):
        u.color = 'GRAY'
        for v in self.graph_dict[u]:
            v.cc = u.cc
            if v.color == 'WHITE':
                self.dfs_visit(v)
        u.color = 'BlACK'      
    \end{lstlisting}

    \begin{lstlisting}
g = Graph()

# First CC
g.add_edge(Node(0), Node(1))
g.add_edge(Node(1), Node(2))
g.add_edge(Node(1), Node(3))

# Second CC
g.add_edge(Node(4), Node(5))
g.add_edge(Node(4), Node(6))
g.add_edge(Node(6), Node(7))

g.dfs()
g.print_graph_dict()

# Output:
# Note the "CC" that says which component it is a part of.
(0, BlACK, CC: 1)
	(1, BlACK, CC: 1)
(1, BlACK, CC: 1)
	(0, BlACK, CC: 1)
	(2, BlACK, CC: 1)
	(3, BlACK, CC: 1)
(2, BlACK, CC: 1)
	(1, BlACK, CC: 1)
(3, BlACK, CC: 1)
  (1, BlACK, CC: 1)
  
(4, BlACK, CC: 2)
	(5, BlACK, CC: 2)
	(6, BlACK, CC: 2)
(5, BlACK, CC: 2)
	(4, BlACK, CC: 2)
(6, BlACK, CC: 2)
	(4, BlACK, CC: 2)
	(7, BlACK, CC: 2)
(7, BlACK, CC: 2)
	(6, BlACK, CC: 2)
    \end{lstlisting}

    \item \textbf{23.1-4 p. 629}.
    
    Say we have a graph $V = \{a, b, c\}$ and $E = \{ab, ac, bc\}$ and weights $W = \{W_{ab} = 1, W_{ac} = 1, W_{bc} = 1\}$ which is simply a triangle of equal weighted edges.  

    Since the edges are equal in weight we have three possible cuts we could make and still have a light edge cut $\{(ab, ac), (ab, bc), (ac, bc)\}$. 

    Thus every edge is technically a light edge for any cut and each cut produces something equal to an MST but not the only MST given the original triangle is a cycle in and of itself.

    \item \textbf{23.1-7 p. 630}.
    
    First lets define what we mean by a tree, "a tree is an undirected graph in which any two vertices are connected by exactly one path". 
    Therefore if we take a subset of edges that connects all verticies and has a minimum total weight of possible edges.
    By definition "a subset of edges that connects all verticies" fufills the first part of the tree defintion. 
    However, "must be connected by exactly one path" will be fufilled by the minimum total weight of edges. Consider that all edge weights are positive therefore mathmatically the fewest number of edges possible would give the lowest possible total edge weight. 
    Also each vertex must be part of at least one edge to connect all verticies therefore there'd only be one possible acyclic path.\\

    To counter this if we allowed negative weights it may benift our proposed graph to include those negitive weight edges. For example if we take a super simple graph with edges \bm{$E = \{ab, ac, bc\}$} and weights \bm{$W_e = {W_{ab} = 1, W_{ac} = 1, W_{bc} = -2}$}.
    We could just take edges $\{ab, ac\}$ and fufill being a subset of edges that connects all verticies with a ttotal weight of 2. However if we took all three edges we'd have a total weight of 0, but in that case we'd form a cyclic graph with multiple paths to each vert which would not be a tree.

  \end{enumerate} % End Questions

\end{document}
