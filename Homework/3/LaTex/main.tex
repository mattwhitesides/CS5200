\documentclass{article}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bm}

\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}

\usepackage[margin=1.25in]{geometry}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.86,0.27,0.22}

\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{CS5200: Homework \#3} % Title of the assignment

\author{Matthew Whitesides\\ \texttt{mbwxd4@mst.edu}} % Author name and email address

\date{\today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

  \maketitle % Print the title
 
  \begin{enumerate}
    \item \textbf{Show that if $L \geq 2$, then every binary tree with L leaves contains a subtree having between L/3 and 2L/3 leaves, inclusive.} \\
    
      First to define a binary tree each leaf has 0, 1, or 2 children. So if we start with the base case $L = 2$ then we claim there's a subtree "S" such that $\frac{2}{3} \leq S \leq \frac{4}{3}$ leaves. 
      Which essentailly is saying there's a subtree tree with one leaf. which has to be true given there's only one possible situation of a two leaf binary tree it's just two connected nodes. \\

      Now lets look at two edge cases as say we have $L = 6$ so our claim is that there's a subtree S such that $2 \leq S \leq 4$. We we say each leaf in the tree has the max possible nodes (2) then our tree could look like, 
      \begin{lstlisting}
        A - B - C - D - E - F

        'Or'

            A
          /   \
         B     C
        / \    /
        D E    F
      \end{lstlisting}
      Which ovbisouly works as well each has subtree's you can see with 2, 3 and 4. \\

      Finally lets assume this theory isn't correct and we say subtree S is $S \leq \frac{L}{3}\;Or\;S \geq \frac{2L}{3}$. That would imply that if you actaully took a subtree greater than $\frac{2L}{3}$ (like in our example above one of 5 leaves) lets call it $Sb$.
      Then following the same rule there would have to be a subtree of $Sb$ which is $L \geq \frac{2(SB Leaves)}{3}$, and we call that subtree $Sc$ which has less than $Sb$ leaves however since $Sc$ obviously has to also be a subtree of our original $S$, that would violate our inverse theroy thus proving the original one has to be true.

      \item \textbf{Let us associate a "weight" \bm{$w(q) = 2^{-depth(q)}$} with each leaf in a binary tree \bm{$T$}. Prove that \bm{$\sum_q w(q) \leq 1$}, where the sum is taken over all leaves \bm{$q$} in \bm{$T$}.} \\
      
      First lets just look at the base case of a single leaf tree. $w(q) = 2^{-depth(q)} = 2^-0 = 1$ which is true however there's techniacally no leaves just the root node. Now let's look at the next most simple case below. \\
      \begin{lstlisting}
            A
          /   \
         B     C
      \end{lstlisting}
      Here we have $\sum_q w(q) = 2^{-depth(C)} + 2^{-depth(C)} = 2^{-1} + 2^{-1} = 1$. \\

      \begin{itemize}
        \item Now when we think about this logically if $n \geq 0$ (which in the case of a binary tree is always true as you can't have a negative depth) then $0 \le 2^{-n} \leq 1$ due to the rules of exponents. 
        \item Also note that $2^{-n} = \frac{1}{2^n}$ due to the rules of exponents.
        \item Know that it will always be true $Leaves\;in\;depth\;q \leq 2*depth(q)$ because each node at depth(q) - 1 can have at most two children due to the rules of binary trees.
        \item Threfore in our worst case senerio at any given depth d is $\sum_1^{2(d - 1)} 2^{-d}$ which equals $4^(-d) (-4 + 4^d)$ which expands to $1 - 4^(1 - d)$ using algebra.
        \item Now you can clearly see that for all $d \geq 1$ that $1 - 4^(1 - d)$ will be less than 1. Therefore even in the worst case the sum of all nodes at depth d will be 1 or less.
      \end{itemize}

      \item \textbf{5.2-4 Hat-Check Problem.} \\
      
        First off we can pretty well know that the odds of a person getting their hat back correctly when being drawn randomly is $\frac{1}{n}$. \\

        Lets define an indicator random variable $X_H$ associated with the customer getting their hat back correctly. 

        \[X_H = I\{H\}\]
        \[
          = \begin{cases}
              1, & \text{if H occurs.}\\
              0, & \text{otherwise.}
            \end{cases}
        \]

        \[E[X_H] = \frac{1}{n}\]

        \[E[X] = \sum_{i=1}^{n} E[X_i] = \sum_{i=1}^{n} \frac{1}{n} = 1\]

        So one person will get their hat, makes sense though. 

        \item \textbf{5.2-5 Inversion.} \\
        
        Essentailly we have two sums of indicator variables here. So lets define $X_{i,j}$ as our indicator variable. Also we're not only looking at the expected value of $A[i] > A[j]$ but that as well as $i < j$. 
        So it'll be the sum of the probability of $A[i] > A[j]$ over iterations where $i < j$.

        \[E[X_{i,j}] = Pr\{A[i] > A[j]\}\]

        Then we want the sum of that over $i < j$.

        \[\sum_{i < j} E[X_{i,j}]\]

        \[= \sum_{i=1}^{n-1}(\sum_{j=i+1}^n E[X_{i,j}])\]

        We want to iterate over each element twice once to compare the possibilty of an inversion to each element where $i < j$ (hince the j = i + 1) and then sum the probability of $A[i] > A[j]$ for each of those. Which we can say since it's a uniform 1,2..n numbers there's a $\frac{1}{2}$ chance.

        \[= \sum_{i=1}^{n-1}(\sum_{j=i+1}^n \frac{1}{2})\]

        Which works out to, (okay I used wolfram alpha to simplify the sum equations but it makes sense when you think about it it's a little less than $n * n * \frac{1}{2} * \frac{1}{2}$ which is two loops over 1/2 probabilities).

        \[= \frac{(n-1)n}{4}\]

        \item \textbf{5.4-1 Birthday Problems.} \\
        
        First lets state the obvious that there's a $\frac{1}{365}$ chance that any given individual has the same birthday as you.
        Also that means there's a $\frac{364}{365}$ chance that they do not have the same birthday as you.
        Therefore the probability of n people not having the same birthday as you is $\frac{364}{365}^n$. \\

        That means we want to find: \[1 - \frac{364}{365}^n \geq 0.5\]
        Which works out to $n \geq 252.652$ or \textbf{253} people before your odds are better than half. \\

        Now to figure out of any two people have their birthday on a specific day of the year is a bit different. 
        If we think about it we essentailly want the inverse of the probability that nobody has their birthday on July 4th or only one person has that.\\

        Therefore the probability of nobody having a July 4th birthday would be $(\frac{364}{365})^n$. 
        And the probability of only one person having a July 4th b-day would be $\binom{n}{1}(\frac{1}{365})(\frac{364}{365})^{n-1}$ (n people chose 1 with a 1/365 change vs 1/364 not happening).
        So in total we want 1 - the odds of both those to be greater than half:

        \[1 - ((\frac{364}{365}^n)+(\binom{n}{1}(\frac{1}{365})(\frac{364}{365})^{n-1})) \geq 0.5\]

        Which works out to $n \geq 612.257$ or at least \textbf{613} people. 

        \item \textbf{6.5-9} \bm{$O(n\;lg\;k)$} \textbf{Time Algorithm.}

        \begin{lstlisting}
          import sys

          class MinHeap: 
              def build_min_heap(self, ar): 
                  self.A = ar
                  self.heap_size = len(ar)
                  
                  for i in range(parent(self.heap_size - 1), 0, -1):
                      self.min_heapify(i)

              def min_heapify(self, i): 
                  l = left(i) 
                  r = right(i)        
                  smallest = i 
                  
                  if l < self.heap_size and self.A[l].value < self.A[i].value: 
                      smallest = l 
                  
                  if r < self.heap_size and self.A[r].value < self.A[smallest].value: 
                      smallest = r 
                  
                  if smallest != i: 
                      if (self.A[i].value < sys.maxsize):
                          print('Exchange: {0}, {1}'.format(self.A[i].value, self.A[smallest].value))
                      else:
                          print('Exchange: MAX, {0}'.format(self.A[smallest].value))
                          
                      self.print_heap()            
                      exchange(self.A, i, smallest) 
                      self.min_heapify(smallest)
            
              def get_min(self): 
                  if self.heap_size <= 0:
                      raise Exception('heap underflow') 
                  return self.A[0] 
            
              def exchange_min(self, base):
                  self.A[0] = base 
                  self.min_heapify(0)
                  
              def print_heap(self):
                  s = ''
                  for i in self.A:
                      if i.value < sys.maxsize:
                          s += '{0}, '.format(i.value)
                      else:
                          s += '{0}, '.format('MAX')
                  s = s.strip()
                  s = s.rstrip(',')
                  s = 'Heap: [{0}]\n'.format(s)
                  print(s)
                  
          class Node:
              def __init__(self, v, i, j): 
                  self.value = v
                  self.i = i
                  self.j = j             

          def parent(i):
              return i // 2
                  
          def left(i): 
              return 2 * i 
            
          def right(i): 
              return (2 * i) + 1
            
          def exchange(A, i, j): 
              temp = A[i] 
              A[i] = A[j] 
              A[j] = temp
              
          def merge_lists(A):
              heap = [] 
              result = []
              r = 0
              
              # Initialize the heap with the first values from each list. (K Time)
              print('Initialize heap in K = {0} time.\n'.format(len(A)))
              for i in range(len(A)): 
                  node = Node(A[i][0], i, 1) 
                  heap.append(node) 
                  r += len(A[i]) 
              
              result = [0] * r
              
              # Build the min heap
              min_heap = MinHeap()    
              min_heap.build_min_heap(heap)
              
              # Put a new min value form the heap into the result list and get a new value for the min_heap (N Time).
              # The heap related tasks run in (Lg K) time.
              print('Build results in N = {0} time.\n'.format(r))
              for i in range(r): 
                  base = min_heap.get_min() 
                  result[i] = base.value 
                  
                  if base.j < len(A[base.i]): 
                      base.value = A[base.i][base.j] 
                      base.j += 1
                  else: 
                      base.value = sys.maxsize 
                      
                  min_heap.exchange_min(base)
                  
              return result
        \end{lstlisting}

        Testing:
        
        \begin{lstlisting}
          a = [[1, 3, 5], [2, 4, 6]]
          result = merge_lists(a)          
          print(result)

          #Output:
          Initialize heap in K = 2 time.

          Build results in N = 6 time.

          Exchange: 3, 2
          Heap: [3, 2]

          Exchange: 4, 3
          Heap: [4, 3]

          Exchange: 5, 4
          Heap: [5, 4]

          Exchange: 6, 5
          Heap: [6, 5]

          Exchange: MAX, 6
          Heap: [MAX, 6]

          #Result:
          [1, 2, 3, 4, 5, 6]
        \end{lstlisting}


        \begin{lstlisting}
          a = [[1, 2, 7], [3, 4, 6]]
          result = merge_lists(a)
          print(result)

          #Output:
          Initialize heap in K = 2 time.

          Build results in N = 6 time.

          Exchange: 7, 3
          Heap: [7, 3]

          Exchange: MAX, 7
          Heap: [MAX, 7]

          #Result:
          [1, 2, 3, 4, 6, 7]
        \end{lstlisting}

        \begin{lstlisting}
          a = [[1, 19], [3, 5, 11], [2, 9, 12, 13]]
          result = merge_lists(a)          
          print(result)

          #Output:
          Initialize heap in K = 3 time.

          Exchange: 3, 2
          Heap: [1, 3, 2]
          
          Build results in N = 9 time.
          
          Exchange: 19, 2
          Heap: [19, 2, 3]
          
          Exchange: 19, 3
          Heap: [2, 19, 3]
          
          Exchange: 9, 3
          Heap: [9, 3, 19]
          
          Exchange: 11, 9
          Heap: [11, 9, 19]
          
          Exchange: 12, 11
          Heap: [12, 11, 19]
          
          Exchange: MAX, 12
          Heap: [MAX, 12, 19]
          
          Exchange: MAX, 19
          Heap: [12, MAX, 19]
          
          Exchange: MAX, 19
          Heap: [MAX, 19, MAX]
          
          #Result:
          [1, 2, 3, 5, 9, 11, 12, 13, 19]
        \end{lstlisting}

        \item \textbf{9.3-1 SELECT Algorithm.}
        Essentailly the SELECT algorithm takes an array groups it into groups of 5 elements, sorts them, takes the median, then sorts and finds the medians of those medians.
        For this we're asking what if we took in groups of 7 instead of 5? 
        If we had $n$ elements we'd have $\frac{n}{7}$ groups and would know that our median is less than 4 of the 7 elements per group. 
        That means that the median of medians is at least less than half of the medians as well so in total we're less than $4(\frac{n}{7} - 2) / 2 = \frac{2n}{7} - 8$.
        Therefore using the same formual from 5 groups but with out new 7 groups. The following worst case time complexity using the remaining groups we are greater than.

        \[T(n) \leq T(n/7) + T(\frac{5n}{7} + 8) + O(n)\]

        Therefore if we assume we have correct constant times we can see that the wost case time is LINEAR.\\

        However if we have groups of 3 then we figure we have $\frac{n}{3}$ groups and in total we'll have $2(\frac{n}{3} - 2) / 2 = \frac{2n}{3} - 2$

        Gives us:

        \[T(n) \leq T(n/3) + T(\frac{2n}{3} + 4) + O(n)\]

        Which shows you that we have a leftover group of n (because we've only seperated out 2/3 groups) to recursivly go though which is not less than O(n) therefore we have a total time above linear time.
        

  \end{enumerate}

\end{document}
