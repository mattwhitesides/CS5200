\documentclass{article}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bm}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.86,0.27,0.22}

\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{CS5200: Homework \#2} % Title of the assignment

\author{Matthew Whitesides\\ \texttt{mbwxd4@mst.edu}} % Author name and email address

\date{\today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

  \maketitle % Print the title
 
  \begin{enumerate}
    \item \textbf{2-4 Inversions}
    \begin{enumerate}
      \item (2, 1), (3, 1), (8, 6), (8, 1), (6, 1)
      \item An array with all elements in decending order would have the most inversions. The first element would need to shift (n - 1) times because there'd be 6 elements to the right that are less, then the second would be (n - 2), etc. Until you get to the last element which is $(n - (n - 1))$ which would be 1. For the simple case of [3, 2, 1] you'd have $(3 - 1)  + (3 - 2) = 3$. Or since we decrease by 1, (n - 1) times you can see it's essentilly half of $n * (n -1)$ so the final solution is \bm{$(n(n - 1)) / 2$}.
      \item Since insertion sort works by iterating over the elements one at a time inserting a target element at the location it becomes in order we get essentilly the same as inversion which finds every element out of order compared to one element. If we look at the insertion sort code specifically "while i > 0 and A[i] > key (or A[J])" we essentilly have our inversion count right there and all that is inside a for loop based on n length, so it'd be safe to say the total worst case running time would be \bm{$O(n + number of inversions)$}.
      \item Inversion merge count.
      \begin{lstlisting}
        def merge(A, p, q, r): 
          num_inv = 0
          n1 = q - p + 1
          n2 = r - q 
          L = [0] * (n1) 
          R = [0] * (n2) 
          
          for i in range(0 , n1): 
              L[i] = A[p + i] 
          for j in range(0 , n2): 
              R[j] = A[q + j + 1] 
      
          i = 0
          j = 0
          k = p
      
          while i < n1 and j < n2: 
              if L[i] <= R[j]: 
                  A[k] = L[i] 
                  i += 1
              else:
                  num_inv = q - i + 1
                  A[k] = R[j] 
                  j += 1
              k += 1
      
          while i < n1: 
              A[k] = L[i] 
              i += 1
              k += 1
      
          while j < n2: 
              A[k] = R[j] 
              j += 1
              k += 1
          
          return num_inv
              
        def merge_sort(A, p, r):
            num_inv = 0
            if p < r:
                q = (p + r) // 2
                num_inv = merge_sort(A, p, q)
                num_inv += merge_sort(A, q + 1, r)
                num_inv += merge(A, p, q, r)            
            return num_inv
      \end{lstlisting}
      \begin{lstlisting}
        A = [2, 3, 8, 6, 1]
        num_inv = merge_sort(A, 0, len(A) - 1)
        print(A)
        print("Number of Inversions: ", num_inv)

        # Output
          # [1, 2, 3, 6, 8]
          # Number of Inversions:  5
      \end{lstlisting}
      I was having a bit of trouble with the exact pseudo code from the book as it appeared to be 1 based index, and wasn't copying over the last element in the array sometimes so I went with a more triditional method that's very simmular. However the key to the inversion counting is in the first loop in the "else" statement if L[i] > R[j] that means you have somthing out of order and since it's merge sort and we can assume the other side of the array is in order (or going to be once joined back) then we have essentill our formula above of n(n - 1)/2 however since we know we're at the midpoint with "q" and i is the number of elements away we are and since we're on 0 based we can convert that to (q - i) + 1.
    \end{enumerate}

    \item \textbf{3-3 Ordering by asymptotic growth rates}
    \begin{enumerate}
      \item First we should probably see if we could simplity any of the functions.
      \begin{enumerate}
        \item $\sqrt{2}^{lg\:n}$ = $\sqrt{n}$
        \item $n^{1/lg\:n} = 2$
        \item $2^{lg\:n} = n$
        \item $4^{lg\:n} = n^2$
      \end{enumerate}
      Also using \textit{Stirling's approximation} we can approximate our factorial a bit.
      \begin{enumerate}
        \item $(lg\:n)! \approx \theta(n\:lg\:n)$
      \end{enumerate}
      Now we can rank them in order such that $g1 = \Omega{(g2)}$ where g2 is the lower bounds of g1, etc...
      \begin{enumerate}
        \item $2^{2^{n+1}}$
        \item $2^{2^n}$
        \item $(n+1)!$ 
        \item $n!$
        \item $e^n$
        \item $n \cdot 2^n$
        \item $2^n$
        \item $(\frac{3}{2})^n$
        \item $(lg\:n)^{lg\:n}$ \textit{"Equivalence below"}
        \item $n^{lg\:lg\:n}$
        \item $lg(n!)$
        \item $n^3$
        \item $n^2$ \textit{"Equivalence below"}
        \item $4^{lg\:n} = n^2$
        \item $n\:lg\:n$
        \item $(lg\:n)! \approx \theta(n\:lg\:n)$
        \item $n$ \textit{"Equivalence below"}
        \item $2^{lg\:n} = n$
        \item $\sqrt{2}^{lg\:n}$ = $\sqrt{n}$
        \item $2^{\sqrt{2\:lg\:n}}$
        \item $lg^2\:n$
        \item $ln\:n$
        \item $\sqrt{lg\:n}$
        \item $ln\:ln\:n$
        \item $2^{lg^{*}n}$
        \item $lg^*(lg\:n)$ \textit{"Approx Equivalence below"}
        \item $lg^*n$
        \item $lg(lg^{*}n)$
        \item $n^{1/lg\:n} = 2$ \textit{"Approx Equivalence below"}
        \item $1$        
      \end{enumerate}
      \item So we want a function that is not in the upper or lower bounds of $gi(n)$. 
      I would say if we want something outside of the range we could just take the smallest or largest one and modify it. 
      Essentially \bm{$2^{2^{n + 2}}$} should work although for the lower end you may still have the same. 
      Maybe you could do like in the "Functional Iteration" section and have something like \bm{$f(n) = -1$} for $i = 0$ and \bm{$f(n) = 2^{2^{n + 2}}$} for $i > 0$.
    \end{enumerate}

    \item \textbf{A.2-4}: $\sum_{k=1}^{n} k^3$ would be monotonically increasing so it would be approximated by itergral bound 1:
    \[ \int_{m-1}^{n} f(x)\:dx \leq \sum_{k=m}^{n} f(k) \leq \int_{m}^{n+1} f(x)\:dx = \]
    \[ \int_{0}^{n} x^3\:dx \leq \sum_{k=1}^{n} k^3 \leq \int_{1}^{n+1} x^3\:dx = \]
    \[\bm{ \frac{n^4}{4} \leq \frac{n^2 (1 + n)^2}{4} \leq \frac{-1 + (1 + n)^4}{4} }\]
    
    \item \textbf{4.5-1} Use the master method to give tight asymptotic bounds for the following recurrences. For all we have $a = 2, b = 4$ so for example we can look at these three basic cases:

    \[O(n^{\log_b a-\epsilon}) = n^{\log_4 2-1} = 1\]
    \[\Theta(n^{\log_b a}) = n^{\log_4 2} = \sqrt{n}\] 
    \[\Omega(n^{\log_b a+\epsilon}) = n^{\log_4 2+2} = n\]
    where $\epsilon = 1\:and\:2$.
    \begin{enumerate}
      \itemsep1em 
      \item $T(n) = 2T(n \mathbin{/} 4) + 1$ \\
      Here we have $f(n) = 1$ when $\epsilon = -1$ so we go with case 1 so \\ \bm{$T(n) = \Theta(n^{\log_4 2}) = \Theta(\sqrt{n})$}.
      \item $T(n) = 2T(n \mathbin{/} 4) + \sqrt{n}$ \\
      Here we have $f(n) = \sqrt{n}$ which equals case 2 so \bm{$T(n) = \Theta(\sqrt{n}\;lg\;n)$}.
      \item $T(n) = 2T(n \mathbin{/} 4) + n$ \\
      Here we have $f(n) = n$ when $\epsilon = +2$ which equals case 3 so \bm{$T(n) = \Theta(n)$}. 
      \item $T(n) = 2T(n \mathbin{/} 4) + n^2$ \\
      Here we have $f(n) = n^2$ when $\epsilon = +14$ which equals case 3 so \\ \bm{$T(n) = \Theta(n^2)$}.
    \end{enumerate}

    \item \textbf{4-3:} Give asymptotic upper and lower bounds for $T(n)$.
    \begin{enumerate}
      \itemsep1em 
      \item $T(n) = 4T(n \mathbin{/} 3) + n\;lg\;n$ \\
      For this $a = 4, b = 3, f(n) = n\;lg\;n, n^{\log_b a} = n^{\log_3 4}$. Using the master method we can see $\log_3 4 \approx O(n^{1.261})$ 
      so if we take a number smaller than $1.261$ i.e. $1.2$ and can prove that $n\;lg\;n = O(n^{1.2})$, when $n \approx 3.65$, therefore we can use case 1.
      and say that \bm{$T(n) = \Theta(n^{\log_3 4})$}.

      \item $T(n) = 3T(n \mathbin{/} 3) + n \mathbin{/} lg\;n$ \\
      For this $f(n) = n \mathbin{/} lg\;n$ unfortunately does not appear to be a asymptoticlly positive function so we cannot use the master method, so we can see if we can reduce it and use substutition.
      $T(n) = 3T(n \mathbin{/} 3) + n \mathbin{/} lg\;n$ = $T(n) = 3T(n \mathbin{/} 3) + n \mathbin{/} lg\;n$

      \item $T(n) = 4T(n \mathbin{/} 2) + n^2 \sqrt{n}$ \\
      For this $a = 4, b = 2, f(n) = n^2 \sqrt{n}, n^{\log_b a} = n^{\log_2 4}$. 
      Using the master method we can see $n^2 \sqrt{n} = n^{2.5}$ and $\log_2 4 = 2$ 
      which 2.5 is less than 2 so we can go with case 3 making \bm{$T(n) = \Theta(n^2 \sqrt{n})$}.

      \item $T(n) = 3T(n \mathbin{/} 3 - 2) + n/2$ \\
      For this $a = 3, b = 3, f(n) = n/2, n^{\log_b a} = n^{\log_3 3} = n$. The -2 in the b part is constant so we can kind of ignore it. 
      Since the growth rate of $n$ is asymptotically the same a growth rate of $n/2$ we can go with case two,
      \bm{$T(n) = \Theta(n\;lg\;n)$}.

      \item $T(n) = 2T(n \mathbin{/} 2) + n/lg\;n$
      \item $T(n) = T(n \mathbin{/} 2) + T(n \mathbin{/} 4) + T(n \mathbin{/} 8) + n$
      Here we can try substutition to see if we can have a constant make $T(n) \leq cn$ as this is a linear function. Plus Essentially if you combine the T(n) +'s you have 1/2 + 1/4 + 1/8 = 7/8ths. \\\\
      $T(n) = T(n \mathbin{/} 2) + T(n \mathbin{/} 4) + T(n \mathbin{/} 8) + n$ \\
      \bm{$\leq \frac{7}{8}cn + n$} \\ 
      \bm{$\leq cn\;when\;c >= 8$}

      \item $T(n) = T(n - 1) + 1/nx$
      \item $T(n) = T(n - 1) + lg\;n$
      \item $T(n) = T(n - 1) + 1/lg\;n$
      \item $T(n) = \sqrt{n}\;T(\sqrt{n}) + n$
    \end{enumerate}

    \item For the sample space we'll determine the options like so:
    
    \[(curtain\;with\;prize, curtain\;initially\;picked, curtain\;revealed\;by\;the\;emcee)\]
    
    And we'll label the three curtians (A,B,C) making our sample space look like this. Given that the curtain revealed by the emcee cannot be the same as the first two options. \\\\
    
    \begin{math} S =
      \left\{
        \begin{array}{l}
          (A,A,B),(A,A,C),(A,B,C),(A,C,B), \\
          (B,A,C),(B,B,A),(B,B,C),(B,C,A), \\
          (C,A,B),(C,B,A),(C,C,A),(C,C,B)
        \end{array}
      \right\}
    \end{math} \\\\
    
    Now out of those options we want to look at the chances of winning w/ and w/o switching. So we'll define our "event" as the player switching. \\\\
    
    Here is our set for the player winning by \textbf{not switching}, i.e. they picked the right door initially:
    
    \[S = \{(A,A,B),(A,A,C),(B,B,A),(B,B,C),(C,C,A),(C,C,B)\}\]

    Here is our set for the player winning by \textbf{switching}:

    \[S = \{(A,B,C),(A,C,B),(B,A,C),(B,C,A),(C,A,B),(C,B,A)\}\]

    Now it would initially appear they both have the same sized set however we now need to look at the probibility of a given event. 
    Lets let A be the event we chose door A and B be the event that curtain 2 is opened empty.
    If the prize is actually behind door A then he will have a 1/2 chance of opening curtain B. If the prize is behind curtain B he will have a 0 chance of opening curtain B, and natually if the prize is behind curtain C he will always open curtain B.

    Thus giving our probabilities as:

    \[Pr\{B\} = (\frac{1}{3})(\frac{1}{2}) + (\frac{1}{3})(0) + (\frac{1}{3})(1) = \frac{1}{2}\]

    That's the chance of chosing curtain A multiplied by each of the curtain opening secenarios. 

    Using the Bayes theorm we can now find $P(A|B)$:

    \[Pr(A|B) = \frac{(\frac{1}{2})(\frac{1}{3})}{\frac{1}{2}} = \frac{1}{3}\]

    Now since we are switching we can also add the probability of \bm{$Pr(A|B) + Pr(A|C) = \frac{2}{3}$} for switching and the remaining \bm{$\Pr(A|B) = \frac{1}{3}$} for staying still.

    \item First we have to assume that prisoner X is correct in that the guard wont tell him directly he's the one to be executed and wont lie otherwise that it is actually not X or the one the guard says. Lets define our sample space: \\
    
    (Guard's pick, Prisoner executed)
    
    \[S = \{(Y,X),(Y,Y),(Z,X),(Z,Z)\}\]

    So we can say kind of that event A is the probability of prisoner X getting executed, and event B of the guard chosing Y. In this case event B has happened so it's probibility is 1 and using our sample set we see that 2/4 options lead X to be executed. So our bayes equation would look like so:
    
    \[\bm{Pr(A|B) = \frac{(\frac{2}{4})(1)}{1} = \frac{1}{2}}\]

    Therefore I believe he is correct the guard has given him better odds by telling him, given we take everyones word for it.



  \end{enumerate}

\end{document}
