\documentclass{article}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bm}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.86,0.27,0.22}

\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{CS5200: Homework \#2} % Title of the assignment

\author{Matthew Whitesides\\ \texttt{mbwxd4@mst.edu}} % Author name and email address

\date{\today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

  \maketitle % Print the title
 
  \begin{enumerate}
    \item \textbf{2-4 Inversions}
    \begin{enumerate}
      \item (2, 1), (3, 1), (8, 6), (8, 1), (6, 1)
      \item An array with all elements in decending order would have the most inversions. The first element would need to shift (n - 1) times because there'd be 6 elements to the right that are less, then the second would be (n - 2), etc. Until you get to the last element which is $(n - (n - 1))$ which would be 1. For the simple case of [3, 2, 1] you'd have $(3 - 1)  + (3 - 2) = 3$. Or since we decrease by 1, (n - 1) times you can see it's essentilly half of $n * (n -1)$ so the final solution is \bm{$(n(n - 1)) / 2$}.
      \item Since insertion sort works by iterating over the elements one at a time inserting a target element at the location it becomes in order we get essentilly the same as inversion which finds every element out of order compared to one element. If we look at the insertion sort code specifically "while i > 0 and A[i] > key (or A[J])" we essentilly have our inversion count right there and all that is inside a for loop based on n length, so it'd be safe to say the total worst case running time would be \bm{$O(n + number of inversions)$}.
      \item Inversion merge count.
      \begin{lstlisting}
        def merge(A, p, q, r): 
          num_inv = 0
          n1 = q - p + 1
          n2 = r - q 
          L = [0] * (n1) 
          R = [0] * (n2) 
          
          for i in range(0 , n1): 
              L[i] = A[p + i] 
          for j in range(0 , n2): 
              R[j] = A[q + j + 1] 
      
          i = 0
          j = 0
          k = p
      
          while i < n1 and j < n2: 
              if L[i] <= R[j]: 
                  A[k] = L[i] 
                  i += 1
              else:
                  num_inv = q - i + 1
                  A[k] = R[j] 
                  j += 1
              k += 1
      
          while i < n1: 
              A[k] = L[i] 
              i += 1
              k += 1
      
          while j < n2: 
              A[k] = R[j] 
              j += 1
              k += 1
          
          return num_inv
              
        def merge_sort(A, p, r):
            num_inv = 0
            if p < r:
                q = (p + r) // 2
                num_inv = merge_sort(A, p, q)
                num_inv += merge_sort(A, q + 1, r)
                num_inv += merge(A, p, q, r)            
            return num_inv
      \end{lstlisting}
      \begin{lstlisting}
        A = [2, 3, 8, 6, 1]
        num_inv = merge_sort(A, 0, len(A) - 1)
        print(A)
        print("Number of Inversions: ", num_inv)

        # Output
          # [1, 2, 3, 6, 8]
          # Number of Inversions:  5
      \end{lstlisting}
      I was having a bit of trouble with the exact pseudo code from the book as it appeared to be 1 based index, and wasn't copying over the last element in the array sometimes so I went with a more triditional method that's very simmular. However the key to the inversion counting is in the first loop in the "else" statement if L[i] > R[j] that means you have somthing out of order and since it's merge sort and we can assume the other side of the array is in order (or going to be once joined back) then we have essentill our formula above of n(n - 1)/2 however since we know we're at the midpoint with "q" and i is the number of elements away we are and since we're on 0 based we can convert that to (q - i) + 1.
    \end{enumerate}

    \item \textbf{3-3 Ordering by asymptotic growth rates}
    \begin{enumerate}
      \item First we should probably see if we could simplity any of the functions.
      \begin{enumerate}
        \item $\sqrt{2}^{lg\:n}$ = $\sqrt{n}$
        \item $n^{1/lg\:n} = 2$
        \item $2^{lg\:n} = n$
        \item $4^{lg\:n} = n^2$
      \end{enumerate}
      Also using \textit{Stirling's approximation} we can approximate our factorial a bit.
      \begin{enumerate}
        \item $(lg\:n)! \approx \theta(n\:lg\:n)$
      \end{enumerate}
      Now we can rank them in order such that $g1 = \Omega{(g2)}$ where g2 is the lower bounds of g1, etc...
      \begin{enumerate}
        \item $2^{2^{n+1}}$
        \item $2^{2^n}$
        \item $(n+1)!$ 
        \item $n!$
        \item $e^n$
        \item $n \cdot 2^n$
        \item $2^n$
        \item $(\frac{3}{2})^n$
        \item $(lg\:n)^{lg\:n}$ \textit{"Equilivalence below"}
        \item $n^{lg\:lg\:n}$
        \item $lg(n!)$
        \item $n^3$
        \item $n^2$ \textit{"Equilivalence below"}
        \item $4^{lg\:n} = n^2$
        \item $n\:lg\:n$
        \item $(lg\:n)! \approx \theta(n\:lg\:n)$
        \item $n$ \textit{"Equilivalence below"}
        \item $2^{lg\:n} = n$
        \item $\sqrt{2}^{lg\:n}$ = $\sqrt{n}$
        \item $2^{\sqrt{2\:lg\:n}}$
        \item $lg^2\:n$
        \item $ln\:n$
        \item $\sqrt{lg\:n}$
        \item $ln\:ln\:n$
        \item $2^{lg^{*}n}$
        \item $lg^*(lg\:n)$ \textit{"Approx Equilivalence below"}
        \item $lg^*n$
        \item $lg(lg^{*}n)$
        \item $n^{1/lg\:n} = 2$ \textit{"Approx Equilivalence below"}
        \item $1$        
      \end{enumerate}
      \item So we want a function that is not in the upper or lower bounds of $gi(n)$. I would say if we want something outside of the range we could just take the smallest or largest one and modify it so essentially \bm{$2^{2^{n + 2}}$} should work although for the lower end you may still have the same so maybe you could do like in the "Functional Iteration" section and have something like \bm{$f(n) = -1$} for $i = 0$ and \bm{$f(n) = 2^{2^{n + 2}}$} for $i > 0$.
    \end{enumerate}
    
  \end{enumerate}

\end{document}
